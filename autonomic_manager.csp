B = <> -- buffer

E = {0,1}
A = {0,1}
P = {2..3}
C = {5..7}
POLICIES = {POLICY_1, POLICY_2} 
--POLICY = (event, condition,action)
POLICY_1 = (0,5,8)
POLICY_2 = (1,6,9)

channel event, monitor, get_data, get_event, analizer, add_e, get_e: E --update_mart == update M@RT
channel action: A
channel store, get_policy
channel execute: A
channel update_mart : E
channel get_mart
channel policy : POLICIES

SYSTEM = SENSORS
		 []
		 ACTUATORS

SENSOR(e) = event.e -> add_e.e -> SENSOR(e)
SENSORS = ||| e : E @ SENSOR(e) 

ACTUATOR(a) = action.a -> event.a -> ACTUATOR(a)
ACTUATORS = ||| a : A @ ACTUATOR(a)


-- buffer 
BUFF(N,s) = #s < N-1 & add_e?e -> BUFF(N,s^<e>)
			[]
			#s > 0 & get_e!(head(s)) -> BUFF(N,tail(s))
-- end buffer

MONITOR = get_e?e -> update_mart!e -> MONITOR

analize(e) = if e == 0 then (0,5,8) else (1,6,9) -- detect_symptom
evaluate(p) = if p == (0,5,8) then 8 else 9

ANALIZER = update_mart?e -> policy!analize(e) -> ANALIZER -- criar a condição se politica existir notificar planner -- if not empty(analize(e)) then policy!analize(e) else ANALIZER

PLANNER = policy?p -> execute!evaluate(p) -> PLANNER -- criar a condição da ação
-- if not empty(evaluate(p)) then execute!evaluate(p) else PLANNER

-- data storage
    -- M@RT mantém o estado do sistema e faz parte da base de conhecimento
   
-- implementar uma função para pegar as políticas na base de dados			
-- DATA(e) = get_state?s -> member(e,KB) & 
-- end data storage

KNOWLEDGE_BASE =  update_mart -> KNOWLEDGE_BASE 
                  []
				  get_policy -> KNOWLEDGE_BASE

-- detect symptom
DETECT_SYMPTOM(p) = NOTIFY_PLANNER -- das políticas presentes detectar o sintoma a partir de um evento
NOTIFY_PLANNER = evaluate!p -> ANALIZER 
-- end detect symptom



--analizer?e -> get_policy -> ANALIZER --DETECT_SYMPTOM(p) -- das políticas selecionadas planejar a ação a ser tomada
--PLANNER = evaluate?p -> change -> execute!a -> PLANNER
--EXECUTER = execute?a -> EXECUTER

TOUCH_POINT(p) = execute?p -> action!p -> TOUCH_POINT(p)


AM = (SYSTEM
         [|{|event|}|] 
     SENSORS) 
         [|{|monitor|}|] 
     (MONITOR
         [|{|update_mart|}|]
     KNOWLEDGE_BASE)
     
assert AM :[deadlock free]
assert AM :[deterministic]
